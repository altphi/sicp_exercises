# some notes for sicp

## aligning the Abelson/Sussman videos with the text covered (WIP)

| Lecture #                                                  | Title                                        | SICP Chapter/Section | Notes                                                                |
|------------------------------------------------------------|----------------------------------------------|----------------------|----------------------------------------------------------------------|
| [1A](https://youtu.be/-J_xL4IGhJA?si=hdQq1Iy3uuvvB57m)     | Overview and Introduction to Lisp            | Chapter 1 (1.1–1.2)  | Introduces Scheme/Lisp basics, expressions, and procedures.          |
| [1B](https://youtu.be/V_7mmwpgJHU?si=pzzQmW_DVTu3iy2n)     | Procedures and Processes; Substitution Model | Chapter 1 (1.1–1.3) | Covers procedure definitions, substitution model, and evaluation.     |
| [2A](https://youtu.be/eJeMOEiHv8c?si=poxco0W0UIet1Rbr)     | Higher-order Procedures                      | Chapter 1 (1.3)      | Focuses on procedures as arguments/returns (e.g., `sum`, `map`).     |
| 2B        | Compound Data                            | Chapter 2 (2.1–2.2)  | Introduces pairs, lists, and data abstraction.                       |
| 3A        | Henderson Picture Language                | Chapter 2 (2.2)      | Uses picture language to illustrate data abstraction and closures.    |
| 3B        | Symbolic Differentiation; Quotation       | Chapter 2 (2.3)      | Covers symbolic data, manipulation, and quotation in Scheme.          |
| 4A        | Pattern-directed Programming; Unification | Chapter 2 (2.4) or 4 (4.3) | Likely touches on pattern matching, possibly logic programming (Ch. 4). |
| 4B        | Generic Operators                        | Chapter 2 (2.4–2.5)  | Discusses generic operations and data-directed programming.           |
| 5A        | Assignment and State                     | Chapter 3 (3.1)      | Introduces mutable state and assignment operations.                  |
| 5B        | Computational Objects                    | Chapter 3 (3.2–3.3)  | Covers modeling objects with state, likely environment model.         |
| 6A        | Streams, Part 1                          | Chapter 3 (3.5)      | Introduces streams for delayed evaluation and infinite sequences.     |
| 6B        | Streams, Part 2                          | Chapter 3 (3.5)      | Continues streams, possibly with applications like series or filters. |
| 7A        | Metacircular Evaluator, Part 1           | Chapter 4 (4.1)      | Introduces Scheme interpreter (eval/apply core).                     |
| 7B        | Metacircular Evaluator, Part 2           | Chapter 4 (4.1)      | Extends evaluator, possibly with environments or special forms.       |
| 8A        | Logic Programming, Part 1                | Chapter 4 (4.3)      | Covers logic programming and query systems (e.g., micro-Prolog).      |
| 8B        | Logic Programming, Part 2                | Chapter 4 (4.3)      | Continues logic programming, possibly unification or query evaluation. |
| 9A        | Register Machines                        | Chapter 5 (5.1–5.2)  | Introduces register machine model and simulation.                    |
| 9B        | Explicit-control Evaluator               | Chapter 5 (5.4)      | Discusses evaluator as a register machine with explicit control.      |
| 10A       | Compilation                              | Chapter 5 (5.5)      | Covers compiling Scheme to register machine code.                    |
| 10B       | Storage Allocation and Garbage Collection | Chapter 5 (5.3)     | Discusses memory management and garbage collection.                  |
